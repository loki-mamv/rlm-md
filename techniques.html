<!DOCTYPE html>
<html lang="en">
<head>
<!-- Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6H85DH0R8S"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-6H85DH0R8S');
</script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Techniques -- RLM Implementation Details | rlm.md</title>
    <meta name="description" content="How Recursive Language Models are implemented: REPL environments, decomposition strategies, sub-call patterns, post-training RLM-Qwen3-8B, and comparison with RAG, sliding window, and context compaction.">
    <meta name="keywords" content="RLM techniques, REPL environment, sub-call patterns, RLM-Qwen3-8B training, RAG comparison, context compaction, long context methods">
    <link rel="canonical" href="https://rlm.md/techniques.html">
    <meta property="og:title" content="Techniques -- RLM Implementation Details">
    <meta property="og:description" content="Decomposition strategies, REPL environments, post-training, and how RLMs compare to RAG and sliding windows.">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctext x='16' y='24' font-family='monospace' font-weight='800' font-size='14' fill='%23c9a84c' text-anchor='middle'%3Erlm%3C/text%3E%3C/svg%3E">
    <link rel="stylesheet" href="style.css">
</head>
<body>

<nav class="site-nav">
    <a href="index.html" class="site-logo">rlm<span class="dot">.md</span></a>
    <button class="nav-toggle" onclick="document.querySelector('.nav-links').classList.toggle('open')" aria-label="Menu">///</button>
    <ul class="nav-links">
        <li><a href="./">Home</a></li>
        <li><a href="fundamentals.html">Fundamentals</a></li>
        <li><a href="techniques.html" class="active">Techniques</a></li>
        <li><a href="research.html">Research</a></li>
        <li><a href="rlm-vs-llm.html">RLM vs LLM</a></li>
        <li><a href="applications.html">Applications</a></li>
        <li><a href="resources.html">Resources</a></li>
        <li><a href="blog/">Blog</a></li>
    </ul>
</nav>

<div class="page-body">
<div class="container">

    <section class="hero fade-in">
        <span class="hero-label">Techniques</span>
        <h1>The engineering behind <span class="accent">symbolic recursion</span></h1>
        <p class="hero-sub">RLMs are a simple idea with nuanced implementation. This page covers the specific techniques: how the REPL works, what decomposition strategies the model uses, how sub-calls are structured, and how RLM-Qwen3-8B was trained on just 1,000 samples.</p>
    </section>

    <hr class="divider">

    <section class="section fade-in">
        <div class="split">
            <div>
                <span class="split-label">The REPL</span>
                <h2>Programmatic examination</h2>
            </div>
            <div>
                <p>The REPL (Read-Eval-Print Loop) is where the magic happens. When an RLM receives a prompt P, it initializes a persistent Python environment with:</p>
                <ul>
                    <li><strong>P as a string variable</strong> -- the full prompt text, accessible by indexing/slicing</li>
                    <li><strong>A sub_rlm() function</strong> -- invokes a fresh RLM on any string, returns the response</li>
                    <li><strong>Standard Python</strong> -- loops, string operations, data structures, everything you'd expect</li>
                </ul>
                <p>The model then generates code in iterative turns. Each turn: write code, execute it, observe metadata about the result (not the full stdout -- just its length and a prefix). This forces the model to keep heavy data in REPL variables rather than polluting its own context window.</p>
                <p>If each turn is trimmed to c tokens, you get at most K/c root iterations (where K is the context window), each of which can launch arbitrarily many sub-calls. In practice, the model self-terminates by setting a "Final" variable when it has its answer.</p>
            </div>
        </div>
    </section>

    <section class="section fade-in">
        <div class="split">
            <div>
                <span class="split-label">Decomposition</span>
                <h2>How models slice their inputs</h2>
            </div>
            <div>
                <p>The model decides its own decomposition strategy. Nobody hardcodes chunk sizes or overlap windows. The model examines metadata about P (length, prefix, type) and writes appropriate slicing code. Common patterns observed in the paper:</p>
                <p><strong>Fixed-size chunking</strong> -- the simplest approach. Split P into N-token chunks, process each with a sub-RLM, aggregate results. Used for straightforward aggregation tasks.</p>
                <p><strong>Semantic chunking</strong> -- the model peeks at P to find natural boundaries (document separators, paragraph breaks, function definitions in code) and splits on those.</p>
                <p><strong>Hierarchical decomposition</strong> -- for tasks requiring deep reasoning, the model might first chunk at a coarse level (documents), then have sub-RLMs further decompose within each document. True recursion, not just one level of delegation.</p>
                <p><strong>Targeted probing</strong> -- for search-like tasks, the model might use BM25-style keyword matching in the REPL to identify relevant sections, then only launch sub-RLMs on those sections. This is why RLMs can be <em>cheaper</em> than base model calls -- selective context access.</p>
                <p>The key difference from RAG or sliding-window approaches: the model is in control. It writes the decomposition logic itself, adapting to the specific task and input structure. No one-size-fits-all chunking strategy imposed from outside.</p>
            </div>
        </div>
    </section>

    <section class="section fade-in">
        <div class="split">
            <div>
                <span class="split-label">Sub-calls</span>
                <h2>Recursive self-invocation</h2>
            </div>
            <div>
                <p>The sub_rlm() function is what gives RLMs their recursive power. When the root model writes:</p>
                <div style="background: var(--bg-alt, rgba(255,255,255,0.02)); padding: 1rem; border-radius: 6px; font-family: monospace; font-size: 0.85rem; margin: 1rem 0; border: 1px solid var(--border);">
                    results = [sub_rlm(f"Classify this text: {chunk}") for chunk in chunks]
                </div>
                <p>Each sub_rlm() call spins up a fresh RLM instance. That instance gets its own REPL, its own context window, its own ability to recurse further. The sub-model can be the same model or a smaller/cheaper one.</p>
                <p>In the paper's GPT-5 experiments, the root model is GPT-5 while sub-calls use GPT-5-mini -- striking a balance between capability and cost. For the Qwen3-Coder experiments, the same model is used throughout.</p>
                <p>This is fundamentally different from autoregressive sub-agent delegation. When Anthropic's agent patterns or similar scaffolds "delegate" to a sub-agent, they verbalize the delegation in their output stream -- one sub-call per generated token sequence. An RLM writes a <em>for loop</em> that launches thousands of sub-calls through a few tokens of code. The semantic work scales with the program, not with the output length.</p>
            </div>
        </div>
    </section>

    <section class="section fade-in">
        <div class="split">
            <div>
                <span class="split-label">Post-training</span>
                <h2>Making RLM-Qwen3-8B</h2>
            </div>
            <div>
                <p>The paper's most surprising result might be how little training it takes to make a model natively recursive.</p>
                <p>RLM-Qwen3-8B was created by fine-tuning Qwen3-8B on just <strong>1,000 filtered trajectories</strong>. These trajectories were generated by running Qwen3-Coder-480B as an RLM with Qwen3-8B sub-calls on tasks from LongBenchPro -- so the training data shows what good RLM behavior looks like from a stronger model.</p>
                <p>The clever insight: training a good sub-call model is roughly the same as training a good general-purpose reasoning model. You don't need to teach the model recursion at both levels simultaneously. Focus on teaching the root model how to manipulate the REPL and launch sub-calls effectively. The sub-call model just needs to be a competent reasoner, which smaller models already are.</p>
                <p>The training domains were deliberately unrelated to the evaluation tasks. No overlap. Yet the model improved by a median of 28.3% across four benchmarks. The RLM scaffold is genuinely task-agnostic -- learning to be recursive in one domain transfers to others.</p>
            </div>
        </div>
    </section>

    <section class="section fade-in">
        <div class="split">
            <div>
                <span class="split-label">Comparison</span>
                <h2>RLMs vs everything else</h2>
            </div>
            <div>
                <p><strong>vs RAG (Retrieval-Augmented Generation)</strong> -- RAG retrieves a fixed number of relevant chunks and feeds them to the model. Great for lookup tasks, terrible for aggregation. If the answer requires reasoning across every chunk in a corpus, RAG can't help you. RLMs can.</p>
                <p><strong>vs Sliding Window / Context Compaction</strong> -- Summarization agents iteratively compress context as it fills up. This works okay for shallow tasks but presumes you can safely forget early details to make room for new ones. For dense reasoning tasks, that assumption is fatal. On BrowseComp-Plus, RLMs outperform the summarization baseline by over 29%.</p>
                <p><strong>vs CodeAct / ReAct Agents</strong> -- These agents can execute code in a loop, but they put the user prompt directly into the model's context. They inherit all the limitations of the base model's context window. Adding BM25 retrieval helps for search tasks but doesn't address aggregation.</p>
                <p><strong>vs CodeAct with Sub-calls</strong> -- The closest baseline. This gives the agent both code execution and the ability to invoke sub-LM calls. But because the prompt is in-context rather than in a variable, it still hits the wall on long inputs. The paper tests this ablation directly: on information-dense tasks, RLMs outperform by 10-59%.</p>
                <p><strong>vs Bigger Context Windows</strong> -- This is the elephant in the room. Why not just wait for 10M-token context windows? Because context rot isn't a scaling problem. It's an attention problem. Bigger windows don't help if the model can't maintain quality across them. RLMs solve the quality problem, not the size problem.</p>
            </div>
        </div>
    </section>

    <section class="section fade-in">
        <div class="split">
            <div>
                <span class="split-label">Environments</span>
                <h2>Sandbox options</h2>
            </div>
            <div>
                <p>The reference implementation supports multiple REPL environments:</p>
                <ul>
                    <li><strong>Local (default)</strong> -- Python exec in the same process. Fine for benchmarking and trusted inputs. Shares the host virtual environment.</li>
                    <li><strong>Docker</strong> -- Runs the REPL in a Docker container for isolation. Uses python:3.11-slim by default.</li>
                    <li><strong>Modal Sandboxes</strong> -- Cloud-based isolated execution via Modal. Full isolation from the host process.</li>
                    <li><strong>Prime Intellect Sandboxes</strong> -- Another cloud sandbox option, currently in beta.</li>
                </ul>
                <p>For production use with untrusted inputs, isolated environments are non-negotiable -- the model is writing and executing arbitrary code. But for research and controlled settings, the local REPL is fast and simple.</p>
            </div>
        </div>
    </section>

    <section class="section fade-in">
        <div class="split">
            <div>
                <span class="split-label">Framework support</span>
                <h2>DSPy, Google ADK, and the ecosystem</h2>
            </div>
            <div>
                <p>RLMs are already being adopted by major frameworks, which tells you something about how seriously the community is taking this.</p>
                <p><strong>DSPy (v3.1.2+)</strong> -- Stanford's programmatic LLM framework has built-in RLM support. You can initialize an RLM with <code>dspy.RLM('articles, question -> trends: list[str]')</code> and it handles the REPL, sub-calls, and aggregation transparently. It supports using a smaller model for sub-calls via the <code>sub_lm</code> parameter to reduce costs.</p>
                <p><strong>Google ADK</strong> -- Liam Connell (Google Cloud) published an enterprise-ready reimplementation of RLMs using Google's Agent Development Kit. The ADK version extends the original paper with two notable innovations: <strong>lazy file loading</strong> (the context object references files on disk or in GCS buckets rather than loading everything into memory) and <strong>parallelism</strong> (sub-calls can run concurrently rather than sequentially). The implementation pushed ADK's primitives to their limits -- the recursive nature required dropping down from LLMAgent to the bare-bones BaseAgent.</p>
                <p><strong>Coding agents</strong> -- As several commentators have noted, tools like Claude Code and Gemini CLI already use sub-agent patterns that resemble RLMs. The difference is that these tools don't externalize the user prompt as a REPL variable, so they're still bounded by context limits on the input side. But the conceptual overlap suggests RLMs may become the default inference pattern for coding agents.</p>
            </div>
        </div>
    </section>

    <section class="section fade-in">
        <div class="split">
            <div>
                <span class="split-label">The bitter lesson</span>
                <h2>Why this is more than a hack</h2>
            </div>
            <div>
                <p>Alex Zhang described RLMs as a "bitter-lesson-pilled approach" on X. The reference is to Rich Sutton's famous essay arguing that general methods leveraging computation always win over clever domain-specific tricks.</p>
                <p>The insight Zhang emphasized: "LMs can often ignore most of their context for certain problems. LMs can more efficiently solve problems when only looking locally at certain parts of their input. The REPL environment provides a programmatic way for the model to peek at and infer long contexts without the model ever actually viewing it. It's a partially observable problem that you're giving the LM, where it can make logical decisions based on the structure of the task and context."</p>
                <p>This framing matters. RLMs aren't a workaround for insufficient context windows. They're an argument that the model shouldn't see the full context in the first place -- that treating the input as a partially observable environment you interact with programmatically is fundamentally more expressive than attention over a flat token sequence.</p>
            </div>
        </div>
    </section>

</div>
</div>

<footer class="site-footer">
    <p>rlm.md -- Built to explain, not to impress. Content updated February 2026.</p>
</footer>

<script>
const obs = new IntersectionObserver((entries) => {
    entries.forEach(e => { if (e.isIntersecting) { e.target.classList.add('visible'); obs.unobserve(e.target); }});
}, { threshold: 0.15 });
document.querySelectorAll('.fade-in').forEach(el => obs.observe(el));
document.querySelectorAll('.nav-links a').forEach(a => {
    a.addEventListener('click', () => document.querySelector('.nav-links').classList.remove('open'));
});
</script>
</body>
</html>
