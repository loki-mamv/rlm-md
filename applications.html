<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Applications -- Where Recursive Language Models Change Things | rlm.md</title>
    <meta name="description" content="Real-world applications of Recursive Language Models: legal document analysis, codebase understanding, book-length summarization, deep research, and integration with Google ADK.">
    <meta name="keywords" content="RLM applications, long document analysis, codebase understanding, legal AI, book summarization, Google ADK, recursive language models use cases">
    <link rel="canonical" href="https://rlm.md/applications.html">
    <meta property="og:title" content="Applications -- Where Recursive Language Models Change Things">
    <meta property="og:description" content="Legal analysis, codebase understanding, deep research, and other tasks that need more than a context window.">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctext x='16' y='24' font-family='monospace' font-weight='800' font-size='14' fill='%23c9a84c' text-anchor='middle'%3Erlm%3C/text%3E%3C/svg%3E">
    <link rel="stylesheet" href="style.css">
</head>
<body>

<nav class="site-nav">
    <a href="index.html" class="site-logo">rlm<span class="dot">.md</span></a>
    <button class="nav-toggle" onclick="document.querySelector('.nav-links').classList.toggle('open')" aria-label="Menu">///</button>
    <ul class="nav-links">
        <li><a href="./">Home</a></li>
        <li><a href="fundamentals.html">Fundamentals</a></li>
        <li><a href="techniques.html">Techniques</a></li>
        <li><a href="research.html">Research</a></li>
        <li><a href="applications.html" class="active">Applications</a></li>
        <li><a href="resources.html">Resources</a></li>
    </ul>
</nav>

<div class="page-body">
<div class="container">

    <section class="hero fade-in">
        <span class="hero-label">Applications</span>
        <h1>Where <span class="accent">infinite context</span> actually matters.</h1>
        <p class="hero-sub">The promise of RLMs isn't just "process longer texts." It's enabling tasks that were previously impossible because they require dense reasoning over inputs that exceed any context window. Here's where that changes things.</p>
    </section>

    <hr class="divider">

    <section class="section fade-in">
        <div class="split">
            <div>
                <span class="split-label">Deep research</span>
                <h2>Reasoning over massive document corpora</h2>
            </div>
            <div>
                <p>The paper benchmarks RLMs on BrowseComp-Plus, a deep research task that requires reasoning over 1,000 documents to answer multi-hop questions. The documents contain gold evidence, supporting evidence, and hard negatives -- mimicking real-world research scenarios where you have a huge corpus and need to find and connect the relevant pieces.</p>
                <p>At 6-11 million tokens of input, no standard model can even fit this in context. RAG helps for simple lookups but fails when the answer requires synthesizing information across multiple documents that wouldn't all appear in a top-k retrieval. The RLM approach lets the model systematically examine the corpus, identify relevant documents, and recursively reason over their connections.</p>
                <p>The business case is obvious: any organization sitting on thousands of reports, memos, research papers, or technical documents could use RLMs to answer questions that span their entire knowledge base. Not retrieval -- actual dense reasoning across everything.</p>
            </div>
        </div>
    </section>

    <section class="section fade-in">
        <div class="split">
            <div>
                <span class="split-label">Code</span>
                <h2>Understanding entire repositories</h2>
            </div>
            <div>
                <p>The LongBench-v2 CodeQA benchmark tests exactly this: given a code repository, answer questions that require understanding the relationships between multiple files. This is the kind of task that developers do every day when onboarding to a new codebase or debugging cross-module issues.</p>
                <p>Current AI coding assistants typically work file-by-file or with a handful of files in context. RLMs can process an entire repository as a single prompt, recursively examining files, tracing dependencies, and building up an understanding of the codebase structure before answering specific questions about it.</p>
                <p>The model writes code to explore the repo -- listing files, reading specific functions, tracing imports -- using the same kind of systematic exploration a human developer would. But it does it across the entire codebase simultaneously, with sub-RLMs processing individual files in parallel.</p>
            </div>
        </div>
    </section>

    <section class="section fade-in">
        <div class="split">
            <div>
                <span class="split-label">Legal</span>
                <h2>Contract analysis at scale</h2>
            </div>
            <div>
                <p>Consider a due diligence review: hundreds of contracts, each dozens of pages, and you need to identify every instance of a specific clause type, compare terms across all agreements, and flag inconsistencies. This is O(n) or O(n^2) work depending on whether you need cross-document comparison.</p>
                <p>Standard models can summarize individual contracts fine. But "find every non-compete clause across 500 employment agreements and identify which ones have terms inconsistent with the master agreement" requires dense processing of every document and comparison across all of them. That's exactly the pattern RLMs excel at -- decompose into individual documents, extract relevant clauses via sub-RLMs, then aggregate and compare.</p>
                <p>The OOLONG benchmark results are directly relevant here. OOLONG requires transforming each chunk of input semantically and then aggregating -- precisely what contract analysis demands. RLMs outperform vanilla GPT-5 by 28.4% on this class of task.</p>
            </div>
        </div>
    </section>

    <section class="section fade-in">
        <div class="split">
            <div>
                <span class="split-label">Books and long-form</span>
                <h2>Processing book-length texts</h2>
            </div>
            <div>
                <p>A typical novel is 80,000-100,000 words, roughly 100K-130K tokens. That fits (barely) in some context windows. But actually reasoning over an entire book -- tracking character arcs, identifying thematic patterns, cross-referencing plot points across chapters -- degrades rapidly even within window limits.</p>
                <p>RLMs make book-length analysis practical. The model can recursively process chapters, extract structured information from each, and then reason over the extracted data. For literary analysis, this means genuine engagement with the full text rather than a lossy summary. For nonfiction, it means synthesizing arguments and evidence across an entire work.</p>
                <p>Scale this up to multiple books -- comparative literature analysis, regulatory code spanning thousands of pages, historical archives -- and you're in territory where no other approach comes close.</p>
            </div>
        </div>
    </section>

    <section class="section fade-in">
        <div class="split">
            <div>
                <span class="split-label">Agent frameworks</span>
                <h2>Integration with Google ADK and other platforms</h2>
            </div>
            <div>
                <p>RLMs are designed as a drop-in replacement for standard LLM completion calls. The API surface is identical: <code>rlm.completion(prompt, model)</code> instead of <code>llm.completion(prompt, model)</code>. This makes integration with existing agent frameworks straightforward.</p>
                <p>The Google ADK (Agent Development Kit) community has already started discussing RLM integration for building agents that need to process long contexts. The pattern fits naturally: any ADK agent that currently hits context limits on long inputs could swap in an RLM completion call and immediately gain the ability to handle 10M+ token inputs.</p>
                <p>The broader implication: as agent systems take on longer-horizon tasks (multi-day research, ongoing monitoring, large-scale analysis), the inputs they accumulate will routinely exceed any context window. RLMs provide the plumbing to handle this without rearchitecting the agent.</p>
                <p>Liam Connell's ADK implementation also introduced <strong>lazy file loading</strong> -- instead of loading all context into memory, the RLM holds references to files on disk or in GCS/Sharepoint. The model calls methods to read metadata and contents on demand. This is a practical extension that makes RLMs viable for enterprise document stores where downloading everything upfront is impossible.</p>
            </div>
        </div>
    </section>

    <section class="section fade-in">
        <div class="split">
            <div>
                <span class="split-label">Task decomposition</span>
                <h2>Not just context splitting -- reasoning delegation</h2>
            </div>
            <div>
                <p>A subtlety that the community coverage has surfaced: RLMs don't just decompose context. They decompose <em>tasks</em>.</p>
                <p>When an agent invokes sub_rlm(), it sets both the query (task definition) and the context that the child agent receives. This means RLMs can tackle reasoning problems that exceed a single model's capacity -- not because the input is too long, but because the reasoning chain itself is too complex for one context window.</p>
                <p>As Liam Connell put it: "Modern LLMs reason by generating streams of text about the problem before coming to a final answer. This is inherently limited by context length. Eventually, there will be a problem that cannot be solved within the context limits of a single language model. Task decomposition via recursive delegation allows the agent to hand off tasks to other agents without burning its own precious reasoning tokens."</p>
                <p>This opens up a second axis of scaling beyond context length: reasoning depth. The root model can delegate sub-problems that themselves require extended reasoning, each in their own fresh context window.</p>
            </div>
        </div>
    </section>

    <section class="section fade-in">
        <div class="split">
            <div>
                <span class="split-label">The pattern</span>
                <h2>When to reach for an RLM</h2>
            </div>
            <div>
                <p>RLMs are not always the right tool. The paper is honest about this: for short inputs within the model's effective context window, vanilla LLM calls are simpler and sometimes better. There's a crossover point around 2^14 tokens (16K) where RLMs start outperforming.</p>
                <p>Use an RLM when:</p>
                <ul>
                    <li>Your input exceeds the model's context window</li>
                    <li>Your input fits in context but the task requires dense reasoning over most of it (not just finding one thing)</li>
                    <li>The task involves cross-referencing or comparing multiple sections of the input</li>
                    <li>You need to scale to millions of tokens</li>
                </ul>
                <p>Don't bother with an RLM when:</p>
                <ul>
                    <li>Your input is short and the task is straightforward</li>
                    <li>You just need to find one specific piece of information (RAG is cheaper)</li>
                    <li>Latency is more important than quality (RLMs add wall-clock time from multiple calls)</li>
                </ul>
            </div>
        </div>
    </section>

</div>
</div>

<footer class="site-footer">
    <p>rlm.md -- Built to explain, not to impress. Content updated February 2026.</p>
</footer>

<script>
const obs = new IntersectionObserver((entries) => {
    entries.forEach(e => { if (e.isIntersecting) { e.target.classList.add('visible'); obs.unobserve(e.target); }});
}, { threshold: 0.15 });
document.querySelectorAll('.fade-in').forEach(el => obs.observe(el));
document.querySelectorAll('.nav-links a').forEach(a => {
    a.addEventListener('click', () => document.querySelector('.nav-links').classList.remove('open'));
});
</script>
</body>
</html>
